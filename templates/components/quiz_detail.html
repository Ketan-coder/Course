{% extends "base.html" %}
{% load static %}

{% block head %}
<link href="https://cdn.jsdelivr.net/npm/halfmoon@2.0.1/css/halfmoon.min.css" rel="stylesheet" integrity="sha384-APseV2Wh8CIbyS12+JAE2iE26oHw35TzTpeH2x2D2U9c9S/2/w+y3d3D0kLzG2dj" crossorigin="anonymous">
<script src="https://unpkg.com/@phosphor-icons/web"></script>

<style>
    :root {
        --quiz-container-max-width: 800px;
        --quiz-transition-speed: 0.4s;
        --hm-primary-bg-color-light: #e6f3ff;
        --hm-success-bg-color-light: #e3fcef;
        --hm-danger-bg-color-light: #fce8e8;
    }

    body {
        background-color: var(--hm-body-bg-color);
    }

    .quiz-wrapper {
        max-width: var(--quiz-container-max-width);
        margin: 3rem auto;
        padding: 0 1rem;
    }

    .quiz-container {
        position: relative;
        overflow: hidden;
    }

    .questions-track {
        display: flex;
        transition: transform var(--quiz-transition-speed) ease-in-out;
    }

    .question-slide {
        width: 100%;
        flex-shrink: 0;
       /* padding: 0 0.5rem; */
    }

    .question-card {
        background-color: var(--hm-content-bg-color);
        border: 1px solid var(--hm-border-color);
        border-radius: var(--hm-border-radius-lg);
        box-shadow: var(--hm-shadow-lg);
        padding: 2rem 2.5rem;
    }
    
    .question-title {
        font-weight: 600;
        font-size: 1.25rem;
        margin-bottom: 2rem;
    }

    .answer-option {
        display: flex;
        align-items: center;
        padding: 1rem;
        border: 1px solid var(--hm-border-color);
        border-radius: var(--hm-border-radius);
        margin-bottom: 0.75rem;
        cursor: pointer;
        transition: all 0.2s ease-in-out;
        transform: scale(1);
    }
    .answer-option:hover {
        border-color: var(--hm-primary-color);
        background-color: var(--hm-hover-bg-color);
        transform: scale(1.02);
    }
    .answer-option input[type="radio"],
    .answer-option input[type="checkbox"] {
        display: none;
    }
    .answer-option.selected {
        background-color: var(--hm-primary-bg-color-dark);
        border-color: var(--hm-primary-color);
        color: var(--hm-primary-color);
        transform: scale(1.02);
        box-shadow: 0 0 0 2px var(--hm-primary-color);
    }
    .answer-option .ph {
        font-size: 1.5rem;
        margin-right: 1rem;
        transition: transform 0.2s ease;
    }
    .answer-option.selected .ph {
        font-weight: bold;
        transform: scale(1.1);
    }
    
    .text-answer-input {
        width: 100%;
        padding: 0.75rem 1rem;
        border-radius: var(--hm-border-radius);
        border: 1px solid var(--hm-border-color);
        background-color: var(--hm-body-bg-color);
        font-size: 1rem;
        min-height: 120px;
    }

    .image-mcq {
        max-width: 100%;
        height: auto;
        border-radius: var(--hm-border-radius);
        margin-bottom: 1rem;
    }

    .image-error {
        color: var(--hm-danger-color);
        margin-bottom: 1rem;
        display: none;
    }

    .drag-drop-sentence {
        font-size: 1.2rem;
        line-height: 2.5;
        padding: 1rem;
        text-align: center;
    }
    .drop-zone {
        display: inline-block;
        min-width: 120px;
        min-height: 40px;
        padding: 0.2rem 0.5rem;
        margin: 0 0.25em;
        vertical-align: middle;
        text-align: center;
        border-bottom: 2px dashed var(--hm-primary-color);
        background-color: var(--hm-hover-bg-color);
        border-radius: var(--hm-border-radius-sm);
        transition: all 0.2s ease;
    }
    .drop-zone.drag-over {
        background-color: var(--hm-primary-bg-color-light);
        border-bottom-style: solid;
    }
    .drop-zone.filled {
        border-bottom-style: solid;
        background-color: var(--hm-content-bg-color);
        color: var(--hm-primary-text-color);
        font-weight: 500;
    }
    .draggable-options-pool {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 0.75rem;
        padding: 1rem;
        margin-top: 1rem;
        border-top: 1px solid var(--hm-border-color);
    }
    .draggable-option {
        padding: 0.5rem 1rem;
        border: 1px solid var(--hm-border-color);
        border-radius: var(--hm-border-radius-lg);
        cursor: grab;
        background-color: var(--hm-content-bg-color);
        transition: opacity 0.2s ease, transform 0.2s ease;
    }
    .draggable-option.dragging {
        opacity: 0.5;
        transform: scale(0.95);
    }

    .results-card {
        text-align: center;
        box-shadow: var(--hm-shadow-lg);
        border-width: 2px;
        padding: 2.5rem 3rem;
        border-radius: var(--hm-border-radius-xl);
        transition: all 0.5s ease-in-out;
    }
    .results-card.pass {
        border-color: var(--hm-success-color);
        background: radial-gradient(circle at top, var(--hm-success-bg-color-light) 0%, var(--hm-content-bg-color) 70%);
        animation: celebrate 1.5s ease-in-out infinite alternate;
    }
    .results-card.fail {
        border-color: var(--hm-danger-color);
        background: radial-gradient(circle at top, var(--hm-danger-bg-color-light) 0%, var(--hm-content-bg-color) 70%);
        animation: shake 0.5s ease-in-out;
    }
    @keyframes celebrate {
        0% { transform: scale(1); }
        100% { transform: scale(1.03); }
    }
    @keyframes shake {
        0%, 100% { transform: translateX(0); }
        25% { transform: translateX(-5px); }
        75% { transform: translateX(5px); }
    }

    .results-icon {
        font-size: 6rem;
        margin-bottom: 1.5rem;
        transition: transform 0.5s ease;
    }
    .results-card.pass .results-icon {
        color: var(--hm-success-color);
        transform: scale(1.2) rotate(-10deg);
    }
    .results-card.fail .results-icon {
        color: var(--hm-danger-color);
        transform: scale(1.1);
    }

    .results-title {
        font-size: 2rem;
        font-weight: 700;
        margin-bottom: 1rem;
    }
    .results-card.pass .results-title { color: var(--hm-success-color); }
    .results-card.fail .results-title { color: var(--hm-danger-color); }

    .results-score {
        font-size: 1.5rem;
        margin: 1rem 0;
    }
    .results-card.pass .results-score { color: var(--hm-success-color-dark); }
    .results-card.fail .results-score { color: var(--hm-danger-color-dark); }

    .results-message {
        font-size: 1.1rem;
        margin-bottom: 2rem;
        max-width: 600px;
        margin-left: auto;
        margin-right: auto;
    }
    .results-card.pass .results-message { color: var(--hm-success-text-color); }
    .results-card.fail .results-message { color: var(--hm-danger-text-color); }

    #confetti-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 1000;
    }

    .completed-screen {
        text-align: center;
        padding: 3rem 2rem;
        background-color: var(--hm-content-bg-color);
        border: 1px solid var(--hm-border-color);
        border-radius: var(--hm-border-radius-lg);
        box-shadow: var(--hm-shadow-lg);
        max-width: 600px;
        margin: 3rem auto;
    }
    .completed-screen .ph {
        font-size: 4rem;
        color: var(--hm-warning-color);
        margin-bottom: 1rem;
    }
    .completed-screen h2 {
        font-size: 1.75rem;
        font-weight: 600;
        margin-bottom: 1rem;
    }
    .completed-screen p {
        font-size: 1.1rem;
        color: var(--hm-text-color);
        margin-bottom: 2rem;
    }

    .error-message {
        color: var(--hm-danger-color);
        margin-top: 1rem;
        display: none;
    }
</style>
{% endblock head %}

{% block body %}
{{ quiz_data|json_script:"quiz-data-json" }}

<div class="quiz-wrapper">
    <h1 id="quiz-title" class="text-center font-weight-bold mb-2"></h1>
    <p id="quiz-progress-text" class="text-center text-muted"></p>

    <div class="progress my-4" style="height: 8px;">
        <div class="progress-bar rounded-pill" id="quiz-progress-bar" role="progressbar" style="width: 0%;"></div>
    </div>

    <div id="quiz-container" class="quiz-container">
        <div id="questions-track" class="questions-track"></div>
    </div>

    <div id="results-screen" class="d-none">
        <div class="card p-4 p-lg-5 results-card position-relative text-center">
            <canvas id="confetti-canvas"></canvas>
            <i id="results-icon" class="ph"></i>
            <h1 id="results-title" class="results-title"></h1>
            <p class="results-score">You scored <strong id="results-score"></strong> out of <strong id="results-total-score"></strong>.</p>
            <p id="results-message" class="results-message"></p>
            <div class="mt-4">
                <a href="{{redirect_url}}" class="btn btn-primary">Back to Course</a>
            </div>
        </div>
    </div>

    <div id="completed-screen" class="d-none completed-screen">
        <i class="ph ph-check-circle"></i>
        <h2>Quiz Completed</h2>
        <p>You have already completed this quiz and cannot resubmit. Thank you for your participation!</p>
        <a href="#" class="btn btn-primary">Back to Course</a>
    </div>

    <div id="quiz-navigation" class="d-flex justify-content-between mt-4">
        <button id="prev-btn" class="btn btn-secondary" disabled>
            <i class="ph ph-arrow-left"></i> Previous
        </button>
        <button id="next-btn" class="btn btn-primary">
            Save & Next <i class="ph ph-arrow-right"></i>
        </button>
    </div>
    <p id="error-message" class="error-message text-center">Please provide an answer before proceeding.</p>
</div>
{% endblock body %}

{% block script %}
<script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.3/dist/confetti.browser.min.js"></script>

<script>
document.addEventListener("DOMContentLoaded", () => {
    // --- SETUP & STATE ---
    const quizData = JSON.parse(document.getElementById('quiz-data-json').textContent);
    const questions = quizData.questions;
    const totalQuestions = questions.length;
    let currentQuestionIndex = 0;
    let userAnswers = {};
    let totalPossibleScore = 0;
    const isCompleted = quizData.is_completed || false;
    questions.forEach(q => totalPossibleScore += q.score_on_completion || 0);

    // --- DOM ELEMENTS ---
    const track = document.getElementById('questions-track');
    const nextBtn = document.getElementById('next-btn');
    const prevBtn = document.getElementById('prev-btn');
    const progressBar = document.getElementById('quiz-progress-bar');
    const progressText = document.getElementById('quiz-progress-text');
    const errorMessage = document.getElementById('error-message');
    const quizContainer = document.getElementById('quiz-container');
    const quizNavigation = document.getElementById('quiz-navigation');
    const resultsScreen = document.getElementById('results-screen');
    const completedScreen = document.getElementById('completed-screen');

    function STR(v) {
        if (v === null || v === undefined) return null;
        return String(v).trim();
    }
    
    function blankIndices(q) {
        const parts = Array.isArray(q.sentence_parts) ? q.sentence_parts : [];
        return parts.map((p, i) => (p === null ? String(i) : null)).filter(v => v !== null);
    }
    
    /**
     * Turn whatever the quiz author provided into:
     *   { "<blankIndex>": "<optionId>", ... }
     * Accepts:
     *   - q.answer or q.correct_mapping
     *   - object keyed by actual blank index (e.g., {"1":"A","3":"B"})
     *   - object keyed 0..n-1 meaning “order of blanks”
     *   - array of ids in order of blanks  (["A","B"])
     *   - full sentence array where non-blanks are literals ([null,"A","to","B"])
     *   - comma string "A,B"
     */
    function normalizeCorrectDragMap(q) {
        const blanks = blankIndices(q); // e.g., ["1","3"]
        let ans = q.answer ?? q.correct_mapping ?? null;
    
        if (ans == null) return {};
    
        // "A,B"
        if (typeof ans === 'string') {
            const ids = ans.split(',').map(s => STR(s)).filter(Boolean);
            const map = {};
            blanks.forEach((idx, pos) => { map[idx] = ids[pos] ?? null; });
            return map;
        }
    
        // ["A","B"] or full sentence array
        if (Array.isArray(ans)) {
            const ids = ans.map(STR);
            const map = {};
            if (ids.length === blanks.length) {
                blanks.forEach((idx, pos) => { map[idx] = ids[pos] ?? null; });
                return map;
            }
            // full sentence array case
            const parts = Array.isArray(q.sentence_parts) ? q.sentence_parts : [];
            if (ids.length === parts.length) {
                parts.forEach((p, i) => {
                    if (p === null) map[String(i)] = STR(ids[i]);
                });
                return map;
            }
        }
    
        // { "1":"A", "3":"B" } or { "0":"A", "1":"B" } meaning order of blanks
        if (typeof ans === 'object') {
            const keys = Object.keys(ans);
            const map = {};
            keys.forEach(k => { map[String(k)] = STR(ans[k]); });
    
            const zeroToN =
                keys.every(k => /^\d+$/.test(k)) &&
                keys.length === blanks.length &&
                keys.map(Number).sort((a,b)=>a-b).every((v,i)=> v === i);
    
            if (zeroToN) {
                const reordered = {};
                blanks.forEach((idx, pos) => { reordered[idx] = STR(ans[pos]); });
                return reordered;
            }
            return map; // assume actual indices
        }
    
        return {};
    }
    
    function normalizeUserDragMap(userMap) {
        if (!userMap || typeof userMap !== 'object') return {};
        const out = {};
        Object.keys(userMap).forEach(k => { out[String(k)] = STR(userMap[k]); });
        return out;
    }
    

    // --- INITIALIZATION ---
    function initializeQuiz() {
        document.getElementById('quiz-title').textContent = quizData.title;
        if (isCompleted) {
            quizContainer.classList.add('d-none');
            quizNavigation.classList.add('d-none');
            const progressBarContainer = progressBar?.parentElement;
            if (progressBarContainer) progressBarContainer.classList.add('d-none');
            if (progressText) progressText.classList.add('d-none');
            completedScreen.classList.remove('d-none');
            return;
        }
        renderAllQuestions();
        updateUI();
    }

    // --- RENDERING ---
    function renderAllQuestions() {
        track.innerHTML = '';
        questions.forEach((q, index) => {
            const slide = document.createElement('div');
            slide.className = 'question-slide';
            slide.innerHTML = `<div class="card question-card" id="question-${q.id}"></div>`;
            track.appendChild(slide);
            renderQuestion(q, index);
        });
    }

    function renderQuestion(question, index) {
        const container = document.getElementById(`question-${question.id}`);
        if (!container) return;

        let optionsHtml = '';
        const questionType = question.type;

        switch (questionType) {
            case 'SINGLE_SELECT':
            case 'MULTIPLE_SELECT': {
                const inputType = questionType === 'SINGLE_SELECT' ? 'radio' : 'checkbox';
                const icon = questionType === 'SINGLE_SELECT' ? 'ph-circle' : 'ph-square';
                const iconSelected = questionType === 'SINGLE_SELECT' ? 'ph-check-circle' : 'ph-check-square';
                question.options.forEach(opt => {
                    optionsHtml += `
                        <label class="answer-option" data-question-id="${question.id}" for="opt_${question.id}_${opt.id}">
                            <input type="${inputType}" id="opt_${question.id}_${opt.id}" name="q_${question.id}" value="${opt.id}">
                            <i class="ph ${icon}" data-icon="${icon}" data-icon-selected="${iconSelected}"></i>
                            <span>${opt.text}</span>
                        </label>`;
                });
                break;
            }
            case 'IMAGE_MC': {
                question.options.forEach(opt => {
                    optionsHtml += `
                        <label class="answer-option" data-question-id="${question.id}" for="opt_${question.id}_${opt.id}">
                            <input type="radio" id="opt_${question.id}_${opt.id}" name="q_${question.id}" value="${opt.id}">
                            <i class="ph ph-circle" data-icon="ph-circle" data-icon-selected="ph-check-circle"></i>
                            <span>${opt.text}</span>
                        </label>`;
                });
                optionsHtml = `
                    <img src="/${question.image}" class="image-mcq" alt="Question image" onerror="this.style.display='none';this.nextElementSibling.style.display='block';">
                    <div class="image-error">Image failed to load. Please select an answer based on the options.</div>
                    ${optionsHtml}`;
                break;
            }
            case 'TEXT': {
                optionsHtml = `<textarea class="form-control text-answer-input" rows="4" placeholder="Type your answer here..." data-question-id="${question.id}"></textarea>`;
                break;
            }
            case 'DRAG_DROP': {
                const sentenceParts = Array.isArray(question.sentence_parts) ? question.sentence_parts : [];
                const draggableOptions = Array.isArray(question.draggable_options) ? question.draggable_options : [];
                const sentenceHtml = sentenceParts.map((part, i) => 
                    part === null ? `<span class="drop-zone" data-index="${i}" data-question-id="${question.id}"></span>` : `<span>${part}</span>`
                ).join('');
                const draggablesHtml = draggableOptions.map(opt =>
                    `<span class="draggable-option" draggable="true" data-id="${opt.id}">${opt.text}</span>`
                ).join('');
                optionsHtml = `
                    <div class="drag-drop-sentence">${sentenceHtml}</div>
                    <div class="draggable-options-pool">${draggablesHtml}</div>`;
                break;
            }
        }
        
        container.innerHTML = `
            <h4 class="question-title">${index + 1}. ${question.question}</h4>
            <div class="answer-container">${optionsHtml}</div>`;
        
        if (questionType === 'DRAG_DROP') {
            setupDragDrop(question.id);
        }
    }

    // --- UI & NAVIGATION ---
    function updateUI() {
        if (isCompleted) return;
        const progress = totalQuestions > 0 ? ((currentQuestionIndex + 1) / totalQuestions) * 100 : 0;
        progressBar.style.width = `${progress}%`;
        progressText.textContent = `Question ${currentQuestionIndex + 1} of ${totalQuestions}`;
        track.style.transform = `translateX(-${currentQuestionIndex * 100}%)`;
        prevBtn.disabled = currentQuestionIndex === 0;
        nextBtn.innerHTML = currentQuestionIndex === totalQuestions - 1 ?
            'Submit Quiz <i class="ph ph-paper-plane-tilt"></i>' :
            'Save & Next <i class="ph ph-arrow-right"></i>';
        nextBtn.classList.remove('btn-success-light', 'btn-danger-light');
        nextBtn.classList.add('btn-primary');
        errorMessage.style.display = 'none';
        restoreAnswer();
    }

    function goToNextQuestion() {
        if (!hasValidAnswer()) {
            errorMessage.style.display = 'block';
            return;
        }
        saveCurrentAnswer();
        const question = questions[currentQuestionIndex];
        const isCorrect = checkAnswer(question, userAnswers[question.id]);

        const originalText = nextBtn.innerHTML;
        nextBtn.disabled = true;
        nextBtn.classList.remove('btn-primary', 'btn-success-light', 'btn-danger-light');
        if (isCorrect) {
            nextBtn.classList.add('btn-success-light');
            nextBtn.innerHTML = 'Correct! <i class="ph ph-check"></i>';
        } else {
            nextBtn.classList.add('btn-danger-light');
            nextBtn.innerHTML = 'Incorrect <i class="ph ph-x"></i>';
        }

        setTimeout(() => {
            nextBtn.disabled = false;
            nextBtn.classList.remove('btn-success-light', 'btn-danger-light');
            nextBtn.classList.add('btn-primary');
            nextBtn.innerHTML = originalText;

            if (currentQuestionIndex < totalQuestions - 1) {
                currentQuestionIndex++;
                updateUI();
            } else {
                showResults();
            }
        }, 1000);
    }

    function goToPrevQuestion() {
        saveCurrentAnswer();
        if (currentQuestionIndex > 0) {
            currentQuestionIndex--;
            updateUI();
        }
    }

    function hasValidAnswer() {
        if (isCompleted) return true;
        const question = questions[currentQuestionIndex];
        const container = document.getElementById(`question-${question.id}`);
        if (!container) return false;

        switch (question.type) {
            case 'SINGLE_SELECT':
            case 'IMAGE_MC':
                return !!container.querySelector(`input[name="q_${question.id}"]:checked`);
            case 'MULTIPLE_SELECT':
                return container.querySelectorAll(`input[name="q_${question.id}"]:checked`).length > 0;
            case 'TEXT':
                const textarea = container.querySelector('.text-answer-input');
                return textarea && textarea.value.trim() !== '';
            case 'DRAG_DROP':
                const dropZones = container.querySelectorAll('.drop-zone');
                return Array.from(dropZones).every(zone => zone.children.length > 0);
        }
        return false;
    }

    // --- ANSWER HANDLING ---
    function handleOptionSelect(e) {
        const label = e.target.closest('.answer-option');
        if (!label) return;
        const input = label.querySelector('input');
        if (!input) return;
        const questionId = label.dataset.questionId;
        const question = questions.find(q => q.id == questionId);
        // console.log('handleOptionSelect triggered for question:', questionId, 'type:', question.type);

        if (question.type === 'SINGLE_SELECT' || question.type === 'IMAGE_MC') {
            document.querySelectorAll(`.answer-option[data-question-id="${questionId}"]`).forEach(optLabel => {
                const isClickedLabel = optLabel === label;
                optLabel.classList.toggle('selected', isClickedLabel);
                const optInput = optLabel.querySelector('input');
                if (optInput) optInput.checked = isClickedLabel;
                const icon = optLabel.querySelector('.ph');
                if (icon) icon.className = `ph ${isClickedLabel ? icon.dataset.iconSelected : icon.dataset.icon}`;
            });
        } else if (question.type === 'MULTIPLE_SELECT') {
            const isSelected = !input.checked; // Toggle based on current input state
            input.checked = isSelected;
            label.classList.toggle('selected', isSelected);
            const icon = label.querySelector('.ph');
            if (icon) icon.className = `ph ${isSelected ? icon.dataset.iconSelected : icon.dataset.icon}`;
        }
    }

    function saveCurrentAnswer() {
        if (isCompleted) return;
        const question = questions[currentQuestionIndex];
        const container = document.getElementById(`question-${question.id}`);
        if (!container) return;

        switch (question.type) {
            case 'SINGLE_SELECT':
            case 'IMAGE_MC': {
                const selectedRadio = container.querySelector(`input[name="q_${question.id}"]:checked`);
                userAnswers[question.id] = selectedRadio ? selectedRadio.value : null;
                break;
            }
            case 'MULTIPLE_SELECT': {
                const selectedCheckboxes = Array.from(container.querySelectorAll(`input[name="q_${question.id}"]:checked`));
                userAnswers[question.id] = selectedCheckboxes.map(cb => cb.value);
                break;
            }
            case 'TEXT': {
                userAnswers[question.id] = container.querySelector('.text-answer-input').value.trim();
                break;
            }
            case 'DRAG_DROP': {
                const answer = {};
                container.querySelectorAll('.drop-zone').forEach(zone => {
                    const droppedItem = zone.querySelector('.draggable-option');
                    answer[zone.dataset.index] = droppedItem ? droppedItem.dataset.id : null;
                });
                userAnswers[question.id] = answer;
                break;
            }
        }
    }

    function restoreAnswer() {
        if (isCompleted) return;
        const question = questions[currentQuestionIndex];
        const savedAnswer = userAnswers[question.id];
        if (savedAnswer === undefined) return;
        const container = document.getElementById(`question-${question.id}`);
        if (!container) return;

        switch (question.type) {
            case 'SINGLE_SELECT':
            case 'IMAGE_MC':
            case 'MULTIPLE_SELECT': {
                container.querySelectorAll('.answer-option').forEach(label => {
                    const input = label.querySelector('input');
                    const isSelected = Array.isArray(savedAnswer) ? savedAnswer.includes(input.value) : savedAnswer === input.value;
                    label.classList.toggle('selected', isSelected);
                    input.checked = isSelected;
                    const icon = label.querySelector('.ph');
                    if (icon) icon.className = `ph ${isSelected ? icon.dataset.iconSelected : icon.dataset.icon}`;
                });
                break;
            }
            case 'TEXT': {
                container.querySelector('.text-answer-input').value = savedAnswer || '';
                break;
            }
            case 'DRAG_DROP': {
                const pool = container.querySelector('.draggable-options-pool');
                if (!pool) return;
                const allOptions = Array.from(pool.children);
                container.querySelectorAll('.drop-zone').forEach(zone => {
                    const index = zone.dataset.index;
                    const droppedId = savedAnswer[index];
                    if (droppedId) {
                        const droppedOption = allOptions.find(opt => opt.dataset.id === droppedId);
                        if (droppedOption) {
                            zone.appendChild(droppedOption);
                            zone.classList.add('filled');
                        }
                    }
                });
                break;
            }
        }
    }

    // --- DRAG & DROP LOGIC ---
    function setupDragDrop(questionId) {
        if (isCompleted) return;
        const container = document.getElementById(`question-${questionId}`);
        const draggables = container.querySelectorAll('.draggable-option');
        const dropZones = container.querySelectorAll('.drop-zone');
        const optionsPool = container.querySelector('.draggable-options-pool');
        let draggedItem = null;

        draggables.forEach(draggable => {
            draggable.addEventListener('dragstart', (e) => {
                draggedItem = e.target;
                setTimeout(() => e.target.classList.add('dragging'), 0);
            });
            draggable.addEventListener('dragend', () => {
                if (draggedItem) draggedItem.classList.remove('dragging');
                draggedItem = null;
            });
        });

        const handleDrop = (targetContainer) => {
            if (targetContainer.children.length > 0 && targetContainer.classList.contains('drop-zone')) {
                optionsPool.appendChild(targetContainer.firstElementChild);
            }
            targetContainer.appendChild(draggedItem);
            targetContainer.classList.add('filled');
        };

        dropZones.forEach(zone => {
            zone.addEventListener('dragover', e => { e.preventDefault(); zone.classList.add('drag-over'); });
            zone.addEventListener('dragleave', () => zone.classList.remove('drag-over'));
            zone.addEventListener('drop', e => { e.preventDefault(); zone.classList.remove('drag-over'); handleDrop(zone); });
        });

        optionsPool.addEventListener('dragover', e => e.preventDefault());
        optionsPool.addEventListener('drop', e => {
            e.preventDefault();
            const parentZone = draggedItem.closest('.drop-zone');
            if (parentZone) parentZone.classList.remove('filled');
            optionsPool.appendChild(draggedItem);
        });
    }

    // --- RESULTS & SUBMISSION ---
    function normalizeId(v) {
        if (v === null || v === undefined) return null;
        return String(v).trim();
    }
    
    function checkAnswer(question, userAnswer) {
        if (userAnswer == null) return false;
    
        const type = question.type;
    
        // SINGLE/IMAGE MC → compare option IDs (stringify both)
        if (type === 'SINGLE_SELECT' || type === 'IMAGE_MC') {
            const correct = STR(question.answer);
            const user = STR(userAnswer);
            return user !== null && correct !== null && user === correct;
        }
    
        // TEXT → case-insensitive exact text
        if (type === 'TEXT') {
            const correct = STR(question.answer)?.toLowerCase() ?? '';
            const user = STR(userAnswer)?.toLowerCase() ?? '';
            return user !== '' && user === correct;
        }
    
        // MULTIPLE SELECT → accept "a,b,c" or ["a","b","c"]
        if (type === 'MULTIPLE_SELECT') {
            const correctArr = Array.isArray(question.answer)
                ? question.answer.map(STR).filter(Boolean)
                : String(question.answer ?? '')
                    .split(',')
                    .map(s => STR(s))
                    .filter(Boolean);
    
            const userArr = Array.isArray(userAnswer) ? userAnswer.map(STR).filter(Boolean) : [];
            if (userArr.length !== correctArr.length) return false;
    
            correctArr.sort();
            userArr.sort();
            return userArr.every((v, i) => v === correctArr[i]);
        }
    
        // DRAG_DROP → normalize both to { "<blankIndex>": "<id>" }
        if (type === 'DRAG_DROP') {
            const expected = normalizeCorrectDragMap(question);
            const user = normalizeUserDragMap(userAnswer);
            const keys = Object.keys(expected);
            if (keys.length === 0) return false;
            return keys.every(k => STR(expected[k]) && STR(expected[k]) === STR(user[k]));
        }
    
        return false;
    }
    

    function getCorrectAnswersText(q) {
        if (q.type === 'SINGLE_SELECT' || q.type === 'IMAGE_MC') {
            const id = normalizeId(q.answer);
            return id ? (q.options.find(o => normalizeId(o.id) === id)?.text || 'No answer') : 'No answer';
        }
        if (q.type === 'MULTIPLE_SELECT') {
            const ids = Array.isArray(q.answer)
                ? q.answer.map(normalizeId).filter(Boolean)
                : String(q.answer ?? '').split(',').map(s => s.trim()).filter(Boolean).map(normalizeId);
            return ids.map(id => q.options.find(o => normalizeId(o.id) === id)?.text).filter(Boolean).join(', ') || 'No answer';
        }
        if (q.type === 'TEXT') {
            return (q.answer ?? 'No answer').toString();
        }
        if (q.type === 'DRAG_DROP') {
            const mapping = q.answer || q.correct_mapping || {};
            const idsInOrder = Object.keys(mapping).sort((a,b)=>Number(a)-Number(b)).map(k => normalizeId(mapping[k]));
            return idsInOrder.map(id => q.draggable_options.find(o => normalizeId(o.id) === id)?.text).filter(Boolean).join(', ') || 'No answer';
        }
        return 'No answer';
    }
    

    function finalizeAndSubmitQuiz() {
        const submission = {};
    
        questions.forEach(q => {
            const userAns = userAnswers[q.id];
            const isCorrect = checkAnswer(q, userAns);   // ✅ use single source of truth
    
            // ---------- human-readable user answer ----------
            let humanAnswers = '';
            switch (q.type) {
                case 'SINGLE_SELECT':
                case 'IMAGE_MC':
                    humanAnswers = userAns
                        ? q.options.find(opt => opt.id == userAns)?.text || 'No answer'
                        : 'No answer';
                    break;
    
                case 'MULTIPLE_SELECT':
                    humanAnswers = Array.isArray(userAns)
                        ? userAns
                            .map(id => q.options.find(opt => opt.id == id)?.text)
                            .filter(Boolean)
                            .join(', ')
                        : 'No answer';
                    break;
    
                case 'TEXT':
                    humanAnswers = userAns || 'No answer';
                    break;
    
                case 'DRAG_DROP':
                    humanAnswers = userAns
                        ? Object.values(userAns)
                            .map(id => q.draggable_options.find(opt => opt.id == id)?.text)
                            .filter(Boolean)
                            .join(', ')
                        : 'No answer';
                    break;
            }
    
            // ---------- human-readable correct answer ----------
            let correct_answers = '';
            switch (q.type) {
                case 'SINGLE_SELECT':
                case 'IMAGE_MC':
                    correct_answers = q.answer
                        ? q.options.find(opt => opt.id == q.answer)?.text || 'No answer'
                        : 'No answer';
                    break;
    
                case 'MULTIPLE_SELECT':
                    correct_answers = Array.isArray(q.answer)
                        ? q.answer
                            .map(id => q.options.find(opt => opt.id == id)?.text)
                            .filter(Boolean)
                            .join(', ')
                        : 'No answer';
                    break;
    
                case 'TEXT':
                    correct_answers = q.answer || 'No answer';
                    break;
    
                case 'DRAG_DROP':
                    if (q.answer) {
                        if (typeof q.answer === 'string') {
                            // already a text string → just use it
                            correct_answers = q.answer;
                        } else {
                            // object of ids or texts
                            correct_answers = Object.values(q.answer)
                                .map(val => {
                                    // try to resolve as ID
                                    const match = q.draggable_options.find(opt => opt.id == val);
                                    return match ? match.text : val; // fallback to raw text
                                })
                                .filter(Boolean)
                                .join(', ');
                        }
                    } else {
                        correct_answers = 'No answer';
                    }
                    break;
                
                
                
                
            }
    
            // ---------- build payload for this question ----------
            submission[q.id] = {
                type: q.type,
                user_answer: userAns || null,
                is_correct: isCorrect,
                score_awarded: isCorrect ? (q.score_on_completion || 0) : 0,
                question_text: q.question || 'No question text available',
                question_type: q.type,
                human_answers: humanAnswers,
                correct_answers: correct_answers
            };
        });
    
        const finalPayload = {
            quiz_id: quizData.id,
            submission: submission
        };
    
        console.log("Final payload to be sent to backend:", JSON.stringify(finalPayload, null, 2));
    
        // ---------- SEND DATA TO BACKEND ----------
        const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]')?.value || '';
        fetch(`{% url 'submit_quiz_api' %}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken
            },
            body: JSON.stringify(finalPayload)
        })
        .then(response => response.json())
        .then(data => {
            console.log('Backend response:', data);
        })
        .catch(error => {
            console.error('Error submitting quiz:', error);
        });
    }
    

    function showResults() {
        let score = 0;
        questions.forEach(q => {
            if (checkAnswer(q, userAnswers[q.id])) {
                score += q.score_on_completion || 0;
            }
        });
    
        const passed = score >= (quizData.passing_marks || 0);
    
        document.getElementById('quiz-container').classList.add('d-none');
        document.getElementById('quiz-navigation').classList.add('d-none');
        const progressBarContainer = document.getElementById('quiz-progress-bar')?.parentElement;
        if (progressBarContainer) progressBarContainer.classList.add('d-none');
        if (progressText) progressText.classList.add('d-none');
    
        const resultsScreen = document.getElementById('results-screen');
        const resultsCard = resultsScreen.querySelector('.results-card');
        resultsScreen.classList.remove('d-none');
        resultsCard.classList.add(passed ? 'pass' : 'fail');
    
        document.getElementById('results-icon').className = `results-icon ph ${passed ? 'ph-trophy' : 'ph-x-circle'}`;
        document.getElementById('results-title').textContent = passed ? 'Congratulations, you passed!' : 'Better luck next time!';
        document.getElementById('results-score').textContent = score;
        document.getElementById('results-total-score').textContent = totalPossibleScore;
        document.getElementById('results-message').textContent = `You needed ${quizData.passing_marks || 0} points to pass.`;
    
        if (passed) launchConfetti(score, totalPossibleScore);
        finalizeAndSubmitQuiz();
    }
    
    

    function launchConfetti(score, totalScore) {
        const canvas = document.getElementById('confetti-canvas');
        if (!canvas || typeof confetti === 'undefined') return;
        const myConfetti = confetti.create(canvas, { resize: true, useWorker: true });
        
        const intensity = totalScore > 0 ? score / totalScore : 0;
        
        myConfetti({
            particleCount: 100 + (200 * intensity),
            spread: 90 + (90 * intensity),
            origin: { y: 0.6 },
            drift: intensity > 0.5 ? 0 : (0.5 - intensity) * 0.2,
            ticks: 200 + (200 * intensity)
        });

        if (intensity > 0.9) {
            setTimeout(() => myConfetti({ particleCount: 100, spread: 120, startVelocity: 45, origin: { x: 0.1, y: 0.8 } }), 200);
            setTimeout(() => myConfetti({ particleCount: 100, spread: 120, startVelocity: 45, origin: { x: 0.9, y: 0.8 } }), 400);
        }
    }

    // --- EVENT LISTENERS ---
    nextBtn.addEventListener('click', goToNextQuestion);
    prevBtn.addEventListener('click', goToPrevQuestion);
    track.addEventListener('click', handleOptionSelect);
    track.addEventListener('change', (e) => {
        if (e.target.matches('input[type="radio"], input[type="checkbox"]')) {
            const label = e.target.closest('.answer-option');
            if (label) {
                handleOptionSelect({ target: label });
            }
        }
    });

    initializeQuiz();
});
</script>
{% endblock script %}